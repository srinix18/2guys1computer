# -*- coding: utf-8 -*-
"""arithmania.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jGrfMjxCn_ZHw3RvXG0J0R1EZzq6L7mz

text to binary file
"""

import pickle

def text_to_binary(input_text_file, output_binary_file):
    # Read text from the input file
    with open(input_text_file, 'r') as f:
        text = f.read()

    # Serialize text to binary using pickle
    binary_data = pickle.dumps(text)

    # Write binary data to the output file
    with open(output_binary_file, 'wb') as f:
        f.write(binary_data)

# Example usage for text to binary conversion
input_text_file = '/content/test.txt'  # Input text file
output_binary_file = 'output_binary1.bin'  # Output binary file

text_to_binary(input_text_file, output_binary_file)

"""encryption of binary file"""

import os
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import padding

def aes_encrypt(key, data):
    # Generate a random IV (Initialization Vector)
    iv = os.urandom(16)

    # Create a Cipher object using AES in CBC mode with PKCS7 padding
    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
    encryptor = cipher.encryptor()

    # Pad the data to be encrypted
    padder = padding.PKCS7(128).padder()
    padded_data = padder.update(data) + padder.finalize()

    # Encrypt the data
    ciphertext = encryptor.update(padded_data) + encryptor.finalize()

    return iv, ciphertext

# Example usage
key = os.urandom(32)  # Generate a random 256-bit (32-byte) key
input_file = '/content/input.bin'  # File containing binary data
output_file = 'encrypted.bin'  # Output file for encrypted data

# Read binary data from input file
with open(input_file, 'rb') as f:
    data = f.read()

# Encrypt the data
iv, ciphertext = aes_encrypt(key, data)

# Write the IV and encrypted data to the output file
with open(output_file, 'wb') as f:
    f.write(iv)
    f.write(ciphertext)

"""encrypted data into the image

"""

import cv2
import numpy as np

def hide_data_in_image(image_path, binary_file_path, output_image_path):
    # Load the image
    image = cv2.imread(image_path)

    # Convert the binary data to binary string
    with open(binary_file_path, 'rb') as file:
        binary_data = file.read()
        binary_string = ''.join(format(byte, '08b') for byte in binary_data)

    # Get the length of the binary string (data length)
    data_length = len(binary_string)

    # Get the shape of the image
    rows, cols, _ = image.shape

    # Counter for the binary string
    binary_index = 0

    # Iterate through each pixel in the image
    for i in range(rows):
        for j in range(cols):
            # Extract RGB values of the pixel
            r, g, b = image[i, j]

            # Convert RGB values to binary strings
            r_binary = format(r, '08b')
            g_binary = format(g, '08b')
            b_binary = format(b, '08b')

            # Manipulate the least significant bit of each color channel
            if binary_index < data_length:
                r_binary = r_binary[:-1] + binary_string[binary_index]
                binary_index += 1
            if binary_index < data_length:
                g_binary = g_binary[:-1] + binary_string[binary_index]
                binary_index += 1
            if binary_index < data_length:
                b_binary = b_binary[:-1] + binary_string[binary_index]
                binary_index += 1

            # Convert binary strings back to integers
            r_new = int(r_binary, 2)
            g_new = int(g_binary, 2)
            b_new = int(b_binary, 2)

            # Update the pixel with the new RGB values
            image[i, j] = [r_new, g_new, b_new]

    # Save the image with hidden data
    cv2.imwrite(output_image_path, image)

# Example usage
image_path = '/content/test_image.png'  # Path to your PNG image file
binary_file_path = '/content/input.bin'  # Path to your binary data file
output_image_path = 'output_image_with_hidden_data1.png'  # Path for the output image with hidden data

# Hide data in the image
hide_data_in_image(image_path, binary_file_path, output_image_path)

"""extracting the encrypted data from the image"""

import cv2

def extract_data_from_image(image_path, output_binary_file):
    # Load the image
    image = cv2.imread(image_path)

    # Initialize an empty binary string to store the extracted data
    extracted_data = ""

    # Get the shape of the image
    rows, cols, _ = image.shape

    # Iterate through each pixel in the image
    for i in range(rows):
        for j in range(cols):
            # Extract RGB values of the pixel
            r, g, b = image[i, j]

            # Extract the LSB (least significant bit) of each color channel
            extracted_data += format(r, '08b')[-1]
            extracted_data += format(g, '08b')[-1]
            extracted_data += format(b, '08b')[-1]

    # Write the extracted data to the output binary file
    with open(output_binary_file, 'wb') as file:
        # Convert the binary string to bytes and write to file
        file.write(int(extracted_data, 2).to_bytes((len(extracted_data) + 7) // 8, byteorder='big'))

# Example usage
image_path = '/content/output_image_with_hidden_data1.png'  # Path to the image file with hidden data
output_binary_file = 'extracted_data2.bin'  # Output binary file to store the extracted data

# Extract data from the image
extract_data_from_image(image_path, output_binary_file)

"""deencrypting data"""

import os
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import padding

def aes_decrypt(key, iv, ciphertext):
    # Create a Cipher object using AES in CBC mode with the provided IV
    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
    decryptor = cipher.decryptor()

    # Decrypt the ciphertext
    padded_data = decryptor.update(ciphertext) + decryptor.finalize()

    # Unpad the decrypted data
    unpadder = padding.PKCS7(128).unpadder()
    data = unpadder.update(padded_data)

    try:
        data += unpadder.finalize()
    except ValueError:
        # If there's a ValueError due to incorrect padding, you may want to handle it appropriately
        print("Error: Invalid padding")

    return data

# Example usage
input_file = 'encrypted.bin'  # Encrypted file containing IV and ciphertext
output_file = 'decrypted_data.bin'  # Output file for decrypted data

# Read IV and ciphertext from the input file
with open(input_file, 'rb') as f:
    iv = f.read(16)  # Read the first 16 bytes as IV
    ciphertext = f.read()  # Read the remaining bytes as ciphertext

# Decrypt the ciphertext
decrypted_data = aes_decrypt(key, iv, ciphertext)

# Write the decrypted data to the output file
with open(output_file, 'wb') as f:
    f.write(decrypted_data)

"""bin to text file"""

import pickle

def binary_to_text(input_binary_file, output_text_file):
    # Read binary data from the input file
    with open(input_binary_file, 'rb') as f:
        binary_data = f.read()

    # Deserialize binary data to text using pickle
    text = pickle.loads(binary_data)

    # Write text to the output file
    with open(output_text_file, 'w') as f:
        f.write(text)

# Example usage for binary to text conversion
input_binary_file = '/content/output_binary1.bin'  # Input binary file
output_text_file = 'output_text23.txt'  # Output text file

binary_to_text(input_binary_file, output_text_file)